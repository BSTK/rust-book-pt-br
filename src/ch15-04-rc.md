## `Rc<T>`, the Reference Counted Smart Pointer

## `Rc<T>`, o Ponteiro Inteligente com Contagem de Referências

In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node, and that node is conceptually owned by all of the edges
that point to it. A node shouldn’t be cleaned up unless it doesn’t have any
edges pointing to it.

Na maioria dos casos, a posse é clara: você sabe exatamente qual variável tem
posse de um dado valor. Contudo, há casos onde um único valor pode ter múltiplos
possuidores. Por exemplo, em uma estrutura de dados em grafo, múltiplas arestas
podem apontar para o mesmo vértice, e esse vértice é conceitualmente possuído
por todas as arestas que apontam para ele. Um vértice não deveria ser liberado a
não ser que ele não tenha mais arestas apontando para ele.

To enable multiple ownership, Rust has a type called `Rc<T>`. Its name is an
abbreviation for *reference counting*, which keeps track of the number of
references to a value to know whether or not a value is still in use. If there
are zero references to a value, the value can be cleaned up without any
references becoming invalid.

Para permitir posse múltipla, o Rust tem um tipo chamado `Rc<T>`. Seu nome é uma
abreviação para *reference counting* (*contagem de referências*) que, como o
nome diz, mantém registro do número de referências a um valor para saber se ele
ainda está em uso ou não. Se há zero referências a um valor, ele pode ser
liberado sem que nenhuma referência se torne inválida.

Imagine `Rc<T>` as a TV in a family room. When one person enters to watch TV,
they turn it on. Others can come into the room and watch the TV. When the last
person leaves the room, they turn off the TV because it’s no longer being used.
If someone turns off the TV while others are still watching it, there would be
uproar from the remaining TV watchers!

Imagine o `Rc<T>` como uma TV numa sala de família. Quando uma pessoa entra para
assistir à TV, ela a liga. Outros podem entrar na sala e assistir à TV. Quando a
última pessoa sai da sala, ela desliga a TV porque essa não está mais em uso. Se
alguém desligasse a TV enquanto outros ainda estão assistindo, haveria revolta
entre os telespectadores restantes!

We use the `Rc<T>` type when we want to allocate some data on the heap for
multiple parts of our program to read, and we can’t determine at compile time
which part will finish using the data last. If we knew which part would finish
last, we could just make that part the data’s owner and the normal ownership
rules enforced at compile time would take effect.

Nós usamos o tipo `Rc<T>` quando queremos alocar algum dado no heap para que
múltiplas partes do nosso programa o leiam, e não conseguimos determinar em
tempo de compilação qual parte irá terminar de usar o dado por último. Se
soubéssemos qual parte terminaria por último, poderíamos simplesmente tornar
aquela parte a possuidora do dado e as regras normais de posse aplicadas em
tempo de compilação teriam efeito.

Note that `Rc<T>` is only for use in single-threaded scenarios. When we discuss
concurrency in Chapter 16, we’ll cover how to do reference counting in
multithreaded programs.

Note que o `Rc<T>` serve apenas para cenários de thread única. Quando
discutirmos concorrência no Capítulo 16, cobriremos como fazer contagem de
referências em programas com múltiplas threads.

### Using `Rc<T>` to Share Data

### Usando `Rc<T>` para Compartilhar Dados

Let’s return to our cons list example in Listing 15-5. Recall that we defined
it using `Box<T>`. This time, we’ll create two lists that both share ownership
of a third list, which conceptually will look similar to Figure 15-3:

Vamos retornar ao nosso exemplo de *cons list* da Listagem 15-5. Lembre-se de
que a definimos usando o `Box<T>`. Desta vez, vamos criar duas listas que
compartilham ambas a posse de uma terceira lista, o que conceitualmente vai se
parecer com a Figura 15-3:

<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />

<img alt="Duas listas que compartilham a posse de uma terceira lista" src="img/trpl15-03.svg" class="center" />

<span class="caption">Figure 15-3: Two lists, `b` and `c`, sharing ownership of
a third list, `a`</span>

<span class="caption">Figura 15-3: Duas listas, `b` e `c`, compartilhando posse
de uma terceira lista, `a`</span>

We’ll create list `a` that contains 5 and then 10. Then we’ll make two more
lists: `b` that starts with 3 and `c` that starts with 4. Both `b` and `c`
lists will then continue on to the first `a` list containing 5 and 10. In other
words, both lists will share the first list containing 5 and 10.

Vamos criar a lista `a` que contém 5 e depois 10. Então criaremos mais duas
listas: `b`, que começa com 3 e `c`, que começa com 4. Ambas as listas `b` e `c`
irão então continuar na lista `a` contendo 5 e 10. Em outras palavras, ambas as
listas irão compartilhar a primeira lista contendo 5 e 10.

Trying to implement this scenario using our definition of `List` with `Box<T>`
won’t work, as shown in Listing 15-17:

Tentar implementar esse cenário usando nossa definição de `List` com `Box<T>`
não irá funcionar, como mostra a Listagem 15-17:

<span class="filename">Filename: src/main.rs</span>

<span class="filename">Arquivo: src/main.rs</span>

```rust,ignore
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

```rust,ignore
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

<span class="caption">Listing 15-17: Demonstrating we’re not allowed to have
two lists using `Box<T>` that try to share ownership of a third list</span>

<span class="caption">Listagem 15-17: Demonstrando que não é possível termos
duas listas usando `Box<T>` que tentam compartilhar posse de uma terceira
lista</span>

When we compile this code, we get this error:

Quando compilamos esse código, recebemos este erro:

``text
error[E0382]: use of moved value: `a`
  --> src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
```

```text
erro[E0382]: uso de valor movido: `a`
  --> src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - valor movido para cá
13 |     let c = Cons(4, Box::new(a));
   |                              ^ valor usado aqui depois de movido
   |
   = nota: o valor é movido porque `a` tem tipo `List`, que não implementa
   a trait `Copy`
```

The `Cons` variants own the data they hold, so when we create the `b` list, `a`
is moved into `b` and `b` owns `a`. Then, when we try to use `a` again when
creating `c`, we’re not allowed to because `a` has been moved.

As variantes `Cons` têm posse dos dados que elas contêm, então quando criamos a
lista `b`, `a` é movida para dentro de `b`, e `b` toma posse de `a`. Então,
quando tentamos usar `a` de novo na criação de `c`, não somos permitidos porque
`a` foi movida.

We could change the definition of `Cons` to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. The borrow checker wouldn’t let us compile
`let a = Cons(10, &Nil);` for example, because the temporary `Nil` value would
be dropped before `a` could take a reference to it.

Poderíamos mudar a definição de `Cons` para guardar referências, mas aí teríamos
que especificar parâmetros de tempo de vida (*lifetime parameters*). Fazendo
isso, estaríamos especificando que cada elemento da lista devesse viver por pelo
menos tanto tempo quanto a lista inteira. O *verificador de empréstimo* (*borrow
checker*) não nos deixaria compilar `let a = Cons(10, &Nil);`, por exemplo,
porque o valor temporário `Nil` seria destruído antes que `a` pudesse receber
uma referência a ele.

Instead, we’ll change our definition of `List` to use `Rc<T>` in place of
`Box<T>`, as shown in Listing 15-18. Each `Cons` variant will now hold a value
and an `Rc<T>` pointing to a `List`. When we create `b`, instead of taking
ownership of `a`, we’ll clone the `Rc<List>` that `a` is holding, which
increases the number of references from one to two and lets `a` and `b` share
ownership of the data in that `Rc<List>`. We’ll also clone `a` when creating
`c`, which increases the number of references from two to three. Every time we
call `Rc::clone`, the reference count to the data within the `Rc<List>` will
increase, and the data won’t be cleaned up unless there are zero references to
it:

Em vez disso, vamos mudar nossa definição de `List` para usar o `Rc<T>` no lugar
do `Box<T>`, como mostra a Listagem 15-18. Cada variante `Cons` agora vai conter
um valor e um `Rc<T>` apontando para uma `List`. Quando criarmos `b`, em vez de
tomar posse de `a`, iremos clonar o `Rc<List>` que `a` está segurando, o que
aumenta o número de referências de uma para duas e permite com que `a` e
`b`compartilhem posse dos dados naquele `Rc<List>`. Também vamos clonar `a`
quando criarmos `c`, o que aumenta o número de referências de duas para três.
Cada vez que chamarmos `Rc::clone`, a contagem de referências ao valor dentro do
`Rc<List>` irá aumentar, e ele não será liberado até que haja zero referências a
ele:

<span class="filename">Filename: src/main.rs</span>

<span class="filename">Arquivo: src/main.rs</span>

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

<span class="caption">Listing 15-18: A definition of `List` that uses
`Rc<T>`</span>

<span class="caption">Listagem 15-18: Uma definição de `List` que usa o
`Rc<T>`</span>

We need to add a `use` statement to bring `Rc<T>` into scope because it’s not
in the prelude. In `main`, we create the list holding 5 and 10 and store it in
a new `Rc<List>` in `a`. Then when we create `b` and `c`, we call the
`Rc::clone` function and pass a reference to the `Rc<List>` in `a` as an
argument.

Precisamos adicionar uma declaração `use` para trazer o `Rc<T>` ao escopo porque
ele não está no prelúdio. Na `main`, criamos a lista contendo 5 e 10 e a
armazenamos em um novo `Rc<List>` em `a`. Então quando criamos `b` e `c`,
chamamos a função `Rc::clone` e passamos uma referência ao `Rc<List>` em `a`
como argumento.

We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rust’s
convention is to use `Rc::clone` in this case. The implementation of
`Rc::clone` doesn’t make a deep copy of all the data like most types’
implementations of `clone` do. The call to `Rc::clone` only increments the
reference count, which doesn’t take much time. Deep copies of data can take a
lot of time. By using `Rc::clone` for reference counting, we can visually
distinguish between the deep copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep copy clones and can disregard calls to
`Rc::clone`.

Poderíamos ter chamado `a.clone()` em vez de `Rc::clone(&a)`, mas a convenção do
Rust é usar `Rc::clone` neste caso. A implementação de `Rc::clone` não faz uma
cópia profunda de todos os dados como faz a implementação de `clone` da maioria
dos tipos. A chamada a `Rc::clone` apenas incrementa a contagem de referências,
o que não leva muito tempo. Cópias profundas de dados podem levar muito tempo.
Usando `Rc::clone` para a contagem de referências, podemos distinguir
visualmente entre os clones de cópia profunda e os clones que incrementam a
contagem de referências. Quando estivermos procurando problemas de desempenho no
código, precisamos apenas considerar os clones de cópia profunda e podemos
ignorar as chamadas a `Rc::clone`.

### Cloning an `Rc<T>` Increases the Reference Count

### Clonar um `Rc<T>` Aumenta a Contagem de Referências

Let’s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the `Rc<List>` in `a`.

Vamos mudar nosso exemplo de trabalho na Listagem 15-18 para podermos ver a
contagem de referências mudando conforme criamos e destruímos referências ao
`Rc<List>` em `a`.

In Listing 15-19, we’ll change `main` so it has an inner scope around list `c`;
then we can see how the reference count changes when `c` goes out of scope. At
each point in the program where the reference count changes, we’ll print the
reference count, which we can get by calling the `Rc::strong_count` function.
This function is named `strong_count` rather than `count` because the `Rc<T>`
type also has a `weak_count`; we’ll see what `weak_count` is used for in the
“Preventing Reference Cycles” section.

Na Listagem 15-19, vamos mudar a `main` para que tenha um escopo interno em
volta da lista `c`; assim poderemos ver como a contagem de referências muda
quando `c` sai de escopo. Em cada ponto do programa onde a contagem de
referências muda, iremos imprimir seu valor, que podemos obter chamando a função
`Rc::strong_count`. Essa função se chama `strong_count` (*contagem das
referências fortes*) em vez de `count` (*contagem*) porque o tipo `Rc<T>` também
tem uma `weak_count` (*contagem das referências fracas*); veremos para que a
`weak_count` é usada na seção "Evitando Ciclos de Referências".

<span class="filename">Filename: src/main.rs</span>

<span class="filename">Arquivo: src/main.rs</span>

```rust
# enum List {
#     Cons(i32, Rc<List>),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

```rust
# enum List {
#     Cons(i32, Rc<List>),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("contagem depois de criar a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("contagem depois de criar b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("contagem depois de criar c = {}", Rc::strong_count(&a));
    }
    println!("contagem depois que c sai de escopo = {}", Rc::strong_count(&a));
}
```

<span class="caption">Listing 15-19: Printing the reference count</span>

<span class="caption">Listagem 15-19: Imprimindo a contagem de
referências</span>

This code prints the following:

Esse código imprime o seguinte:

```text
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

```text
contagem depois de criar a = 1
contagem depois de criar b = 2
contagem depois de criar c = 3
contagem depois que c sai de escopo = 2
```

We can see that the `Rc<List>` in `a` has an initial reference count of one;
then each time we call `clone`, the count goes up by one. When `c` goes out of
scope, the count goes down by one. We don’t have to call a function to decrease
the reference count like we have to call `Rc::clone` to increase the reference
count: the implementation of the `Drop` trait decreases the reference count
automatically when an `Rc<T>` value goes out of scope.

Podemos ver que o `Rc<List>` em `a` tem uma contagem de referências inicial de
um; depois, cada vez que chamamos `clone`, a contagem aumenta em um. Quando `c`
sai de escopo, a contagem diminui em um. Nós não temos que chamar uma função
para decrementar a contagem de referências como temos que fazer com a
`Rc::clone` para incrementá-la: a implementação da trait `Drop` diminui a
contagem automaticamente quando um valor `Rc<T>` sai de escopo.

What we can’t see in this example is that when `b` and then `a` go out of scope
at the end of `main`, the count is then 0, and the `Rc<List>` is cleaned up
completely at that point. Using `Rc<T>` allows a single value to have
multiple owners, and the count ensures that the value remains valid as long as
any of the owners still exist.

O que não conseguimos ver nesse exemplo é que quando `b` e depois `a` saem de
escopo no final da `main`, a contagem se torna 0, e o `Rc<List>` é
liberado por completo nesse ponto. O uso do `Rc<T>` permite que um único valor
tenha múltiplos possuidores, e a contagem garante que o valor permaneça válido
enquanto algum dos possuidores ainda existir.

Via immutable references, `Rc<T>` allows us to share data between multiple
parts of our program for reading only. If `Rc<T>` allowed us to have multiple
mutable references too, we might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we’ll discuss the interior mutability pattern and the `RefCell<T>`
type that we can use in conjunction with an `Rc<T>` to work with this
immutability restriction.

Por funcionar com referências imutáveis, o `Rc<T>` nos permite compartilhar
dados entre diversas partes do nosso programa *apenas para leitura*. Se o
`Rc<T>` nos deixasse ter múltiplas referências mutáveis também, nós poderíamos
violar uma das regras de empréstimo discutidas no Capítulo 4: múltiplos
empréstimos mutáveis do mesmo lugar podem causar corridas de dados (*data
races*) e inconsistências. Mas conseguir modificar dados é muito útil! Na
próxima seção, discutiremos a pattern de mutabilidade interior (*interior
mutability*) e o tipo `RefCell<T>` que podemos usar junto com um `Rc<T>` para
trabalhar com essa restrição de imutabilidade.
